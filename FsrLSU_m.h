//
// Generated file, do not edit! Created by opp_msgtool 6.2 from networklayer/fsr/FsrLSU.msg.
//

#ifndef __INET_FSRLSU_M_H
#define __INET_FSRLSU_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// opp_msgtool version check
#define MSGC_VERSION 0x0602
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgtool: 'make clean' should help.
#endif


namespace inet {

class LinkInfo;
class LinkState;
class LSUPacket;
struct ScopePeriod;
class FsrScopesParam;

}  // namespace inet

#include "inet/common/INETDefs_m.h" // import inet.common.INETDefs

#include "inet/common/packet/chunk/Chunk_m.h" // import inet.common.packet.chunk.Chunk

#include "inet/networklayer/contract/ipv4/Ipv4Address_m.h" // import inet.networklayer.contract.ipv4.Ipv4Address


namespace inet {

// cplusplus {{
using namespace inet;
// }}

/**
 * Class generated from <tt>networklayer/fsr/FsrLSU.msg:13</tt> by opp_msgtool.
 * <pre>
 * // This LinkInfo class is used in the implementation, but not in the protocol definition.
 * // It is not part of the LSU.
 * class LinkInfo
 * {
 *     Ipv4Address address;
 *     unsigned long cost = 1; // This also acts as distance in SPF algorithm
 * }
 * </pre>
 */
class LinkInfo
{
  protected:
    Ipv4Address address;
    unsigned long cost = 1;

  private:
    void copy(const LinkInfo& other);

  protected:
    bool operator==(const LinkInfo&) = delete;

  public:
    LinkInfo();
    LinkInfo(const LinkInfo& other);
    virtual ~LinkInfo();
    LinkInfo& operator=(const LinkInfo& other);
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    virtual const Ipv4Address& getAddress() const;
    virtual Ipv4Address& getAddressForUpdate() { return const_cast<Ipv4Address&>(const_cast<LinkInfo*>(this)->getAddress());}
    virtual void setAddress(const Ipv4Address& address);

    virtual unsigned long getCost() const;
    virtual void setCost(unsigned long cost);


  public:
    LinkInfo(Ipv4Address address, unsigned long cost);
    bool operator>(const LinkInfo& other) const;
};

/**
 * Class generated from <tt>networklayer/fsr/FsrLSU.msg:36</tt> by opp_msgtool.
 * <pre>
 * class LinkState
 * {
 *     \@packetData;
 *     Ipv4Address routerId;
 * 
 *     Ipv4Address links[]; // Addresses of directly connected neighbors. Cost is 1.
 *     simtime_t timestamp = 0; // Time at which link state was generated at source node (node that the address belongs to)
 * }
 * </pre>
 */
class LinkState
{
  protected:
    Ipv4Address routerId;
    Ipv4Address *links = nullptr;
    size_t links_arraysize = 0;
    ::omnetpp::simtime_t timestamp = 0;

  private:
    void copy(const LinkState& other);

  protected:
    bool operator==(const LinkState&) = delete;

  public:
    LinkState();
    LinkState(const LinkState& other);
    virtual ~LinkState();
    LinkState& operator=(const LinkState& other);
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    virtual const Ipv4Address& getRouterId() const;
    virtual Ipv4Address& getRouterIdForUpdate() { return const_cast<Ipv4Address&>(const_cast<LinkState*>(this)->getRouterId());}
    virtual void setRouterId(const Ipv4Address& routerId);

    virtual void setLinksArraySize(size_t size);
    virtual size_t getLinksArraySize() const;
    virtual const Ipv4Address& getLinks(size_t k) const;
    virtual Ipv4Address& getLinksForUpdate(size_t k) { return const_cast<Ipv4Address&>(const_cast<LinkState*>(this)->getLinks(k));}
    virtual void setLinks(size_t k, const Ipv4Address& links);
    virtual void insertLinks(size_t k, const Ipv4Address& links);
    [[deprecated]] void insertLinks(const Ipv4Address& links) {appendLinks(links);}
    virtual void appendLinks(const Ipv4Address& links);
    virtual void eraseLinks(size_t k);

    virtual ::omnetpp::simtime_t getTimestamp() const;
    virtual void setTimestamp(::omnetpp::simtime_t timestamp);
};

/**
 * Class generated from <tt>networklayer/fsr/FsrLSU.msg:45</tt> by opp_msgtool.
 * <pre>
 * class LSUPacket extends FieldsChunk
 * {
 *     Ipv4Address srcAddress;
 *     LinkState linkStates[];
 * }
 * </pre>
 */
class LSUPacket : public ::inet::FieldsChunk
{
  protected:
    Ipv4Address srcAddress;
    LinkState *linkStates = nullptr;
    size_t linkStates_arraysize = 0;

  private:
    void copy(const LSUPacket& other);

  protected:
    bool operator==(const LSUPacket&) = delete;

  public:
    LSUPacket();
    LSUPacket(const LSUPacket& other);
    virtual ~LSUPacket();
    LSUPacket& operator=(const LSUPacket& other);
    virtual LSUPacket *dup() const override {return new LSUPacket(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual const Ipv4Address& getSrcAddress() const;
    virtual Ipv4Address& getSrcAddressForUpdate() { handleChange();return const_cast<Ipv4Address&>(const_cast<LSUPacket*>(this)->getSrcAddress());}
    virtual void setSrcAddress(const Ipv4Address& srcAddress);

    virtual void setLinkStatesArraySize(size_t size);
    virtual size_t getLinkStatesArraySize() const;
    virtual const LinkState& getLinkStates(size_t k) const;
    virtual LinkState& getLinkStatesForUpdate(size_t k) { handleChange();return const_cast<LinkState&>(const_cast<LSUPacket*>(this)->getLinkStates(k));}
    virtual void setLinkStates(size_t k, const LinkState& linkStates);
    virtual void insertLinkStates(size_t k, const LinkState& linkStates);
    [[deprecated]] void insertLinkStates(const LinkState& linkStates) {appendLinkStates(linkStates);}
    virtual void appendLinkStates(const LinkState& linkStates);
    virtual void eraseLinkStates(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const LSUPacket& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, LSUPacket& obj) {obj.parsimUnpack(b);}

/**
 * Struct generated from networklayer/fsr/FsrLSU.msg:50 by opp_msgtool.
 */
struct ScopePeriod
{
    ScopePeriod();
    unsigned int scope = 0;
    ::omnetpp::simtime_t period = SIMTIME_ZERO;
};

// helpers for local use
void __doPacking(omnetpp::cCommBuffer *b, const ScopePeriod& a);
void __doUnpacking(omnetpp::cCommBuffer *b, ScopePeriod& a);

inline void doParsimPacking(omnetpp::cCommBuffer *b, const ScopePeriod& obj) { __doPacking(b, obj); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, ScopePeriod& obj) { __doUnpacking(b, obj); }

/**
 * Class generated from <tt>networklayer/fsr/FsrLSU.msg:55</tt> by opp_msgtool.
 * <pre>
 * class FsrScopesParam extends cOwnedObject
 * {
 *     ScopePeriod scopes[];
 * }
 * </pre>
 */
class FsrScopesParam : public ::omnetpp::cOwnedObject
{
  protected:
    ScopePeriod *scopes = nullptr;
    size_t scopes_arraysize = 0;

  private:
    void copy(const FsrScopesParam& other);

  protected:
    bool operator==(const FsrScopesParam&) = delete;

  public:
    FsrScopesParam(const char *name=nullptr);
    FsrScopesParam(const FsrScopesParam& other);
    virtual ~FsrScopesParam();
    FsrScopesParam& operator=(const FsrScopesParam& other);
    virtual FsrScopesParam *dup() const override {return new FsrScopesParam(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual void setScopesArraySize(size_t size);
    virtual size_t getScopesArraySize() const;
    virtual const ScopePeriod& getScopes(size_t k) const;
    virtual ScopePeriod& getScopesForUpdate(size_t k) { return const_cast<ScopePeriod&>(const_cast<FsrScopesParam*>(this)->getScopes(k));}
    virtual void setScopes(size_t k, const ScopePeriod& scopes);
    virtual void insertScopes(size_t k, const ScopePeriod& scopes);
    [[deprecated]] void insertScopes(const ScopePeriod& scopes) {appendScopes(scopes);}
    virtual void appendScopes(const ScopePeriod& scopes);
    virtual void eraseScopes(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const FsrScopesParam& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, FsrScopesParam& obj) {obj.parsimUnpack(b);}


}  // namespace inet


namespace omnetpp {

inline any_ptr toAnyPtr(const inet::LinkInfo *p) {if (auto obj = as_cObject(p)) return any_ptr(obj); else return any_ptr(p);}
template<> inline inet::LinkInfo *fromAnyPtr(any_ptr ptr) { return ptr.get<inet::LinkInfo>(); }
inline any_ptr toAnyPtr(const inet::LinkState *p) {if (auto obj = as_cObject(p)) return any_ptr(obj); else return any_ptr(p);}
template<> inline inet::LinkState *fromAnyPtr(any_ptr ptr) { return ptr.get<inet::LinkState>(); }
template<> inline inet::LSUPacket *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::LSUPacket*>(ptr.get<cObject>()); }
inline any_ptr toAnyPtr(const inet::ScopePeriod *p) {return any_ptr(p);}
template<> inline inet::ScopePeriod *fromAnyPtr(any_ptr ptr) { return ptr.get<inet::ScopePeriod>(); }
template<> inline inet::FsrScopesParam *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::FsrScopesParam*>(ptr.get<cObject>()); }

}  // namespace omnetpp

#endif // ifndef __INET_FSRLSU_M_H

